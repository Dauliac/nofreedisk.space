<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Nofreedisk.Space blog</title>
        <link>https://nofreedisk.space/posts/</link>
        <description>Recent content in Posts on Nofreedisk.Space blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 12 Aug 2019 18:49:49 +0200</lastBuildDate>
        <atom:link href="https://nofreedisk.space/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Make dev happy</title>
            <link>https://nofreedisk.space/posts/make-dev-happy/</link>
            <pubDate>Mon, 12 Aug 2019 18:49:49 +0200</pubDate>
            
            <guid>https://nofreedisk.space/posts/make-dev-happy/</guid>
            <description>Les Makefiles si vous avez d√©j√† cod√© en c cet outil a du autant vous prendre la t√™te que vous apporter de l&amp;rsquo;aide.
Pour ceux qui ne connaissent pas:
 Make est un logiciel qui construit automatiquement des fichiers, souvent ex√©cutables, ou des biblioth√®ques √† partir d&amp;rsquo;√©l√©ments de base tels que du code source. Dans notre cas c&amp;rsquo;est les pseudos flags (les targets) qui vont nous int√©resser. L&amp;rsquo;appel des targets se faisant tr√®s facilement:</description>
            <content type="html"><![CDATA[

<p>Les <code>Makefiles</code> si vous avez d√©j√† cod√© en <a href="https://fr.wikipedia.org/wiki/C_(langage)"><code>c</code></a> cet outil a du autant vous prendre la t√™te que vous apporter de l&rsquo;aide.</p>

<p>Pour ceux qui ne connaissent pas:</p>

<blockquote>
<p>Make est un logiciel qui construit automatiquement des fichiers, souvent ex√©cutables, ou des biblioth√®ques √† partir d&rsquo;√©l√©ments de base tels que du code source.
Dans notre cas c&rsquo;est les pseudos flags (les targets) qui vont nous int√©resser.
L&rsquo;appel des targets se faisant tr√®s facilement:</p>

<p><a href="https://fr.wikipedia.org/wiki/Makefile">source Wikip√©dia</a></p>
</blockquote>

<p>info ap√©ro: <em>le logiciel Makefile fut cr√©e en 1977.</em></p>

<p>Fort heureusement pour vous nous ne parlerons pas de cette utilisation.</p>

<p>√áa c&rsquo;√©tait pour l&rsquo;intro ni utile, ni n√©cessaire ü§î.</p>

<hr />

<h2 id="mise-en-situation">Mise en situation</h2>

<p>Dans le cadre du d√©veloppement d&rsquo;un projet il est facile de nommer/normer les actions redondantes (run, stop, clean). On peut m√™me mettre des raccourcis dans son IDE ou se faire des scripts <code>bash</code> pour les plus barbus.
C&rsquo;est bien √ßa cr√©er des habitudes, des rep√®res, point d&rsquo;accroche, <del>un foyer</del>.</p>

<p>On peut √©galement reproduire cette nomenclature sur tous nos projets et √ßa c&rsquo;est cool !</p>

<p><strong>Note:</strong> La normalisation des actions reproductible permet √©galement dans le cadre de pipelines de CI/CD d&rsquo;effectuer des actions et des changements de code sans changer tous les pipelines qui vont d√©pendre d&rsquo;un projet donn√©.</p>

<p>Les Makefile vont donc permettre tout cela et ce sans d√©bourser le moindre centime (Manquerai plus que √ßa).</p>

<p><img src="/img/meme/money_the_mask.gif" alt="The mask money" /></p>

<p>La structure d&rsquo;un <code>Makefile</code> et le syst√®me de <code>targets</code> est exactement appropri√© √† ces probl√©matiques.
Une <code>target</code> une action. Les actions peuvent en impliquer d&rsquo;autres les targets aussi&hellip;</p>

<pre><code class="language-bash">$ make apply            # Pour appliquer
$ make run              # Pour lancer
$ make vous avez saisis # Pour vous, avez et saisis
</code></pre>

<p>Un <code>$ make build</code> restera <code>$ make build</code> pour vos projets et vous üëå. Libre √† vous de changer l&rsquo;action de build avec des variables d&rsquo;environnements ou des conditions.</p>

<p>Un autre argument est que <a href="https://docs.microsoft.com/fr-fr/windows/wsl/about">le sous-syst√®me Linux</a> est d√©sormais bien int√©gr√© √† Windows et vous permet m√™me de <a href="https://medium.com/@sebagomez/installing-the-docker-client-on-ubuntus-windows-subsystem-for-linux-612b392a44c4">faire du docker sur votre h√¥te Windows depuis votre <code>Makefile</code> dans le sous-syst√®me</a>.</p>

<p><strong>Votre outil est donc (en th√©orie) agnostique de l&rsquo;os et de la plateforme.</strong> Pas mal hein üôÇ ?</p>

<hr />

<h2 id="exempli-gratia">Exempli gratia</h2>

<p>Voici un <code>Makefile</code> d&rsquo;exemple pour faire du <code>golang</code>. Nous allons donc le diss√©quer (ou pas d&rsquo;ailleurs, mais ca peut toujours servir).</p>

<pre><code class="language-make">#!make

.PHONY: all
export SHELL := /bin/bash
.DEFAULT_GOAL := all

BINARY = vmctl

help: ## This help.
	@awk 'BEGIN {FS = &quot;:.*?## &quot;} /^[a-zA-Z_-]+:.*?## / {printf &quot;\033[36m%-30s\033[0m %s\n&quot;, $$1, $$2}' $(MAKEFILE_LIST)

all: test build ## Go Test and build
	@echo &quot;+ $@&quot;

test: ## Run go test
	@echo &quot;+ $@&quot;
	go test -v ./...

install: ## Install vmctl
	@echo &quot;+ $@&quot;
	sudo cp vmctl /usr/local/bin/vmctl

build: ## Go build
	@echo &quot;+ $@&quot;
	go build -v
</code></pre>

<h3 id="documentation-en-vrac">Documentation en vrac:</h3>

<ul>
<li>Ajoutez toujours un <code>#!make</code>. Mettre un <a href="https://fr.wikipedia.org/wiki/Shebang">shebang</a> c&rsquo;est toujours une bonne pratique.</li>
<li>Le <code>.PHONY:</code> permet de r√©√©crire des commandes bash par des targets portant le m√™me nom. Lui attribuer <code>all</code> apellera par d√©faut les <code>targets</code> √† la place des commandes <code>bash</code></li>
<li><code>export SHELL := /bin/bash</code> Permet d&rsquo;√©viter des bugs de shells sur Mac Os et d&rsquo;utiliser <code>sh</code> √† la place de <code>bash</code></li>
<li><code>.DEFAULT_GOAL := all</code> est target appel√© si aucun n&rsquo;est pr√©cis√©e: <code>$ make</code></li>
<li>Executer <code>@echo &quot;+ $@&quot;</code> en premi√®re commande permet d&rsquo;afficher le nom de la <code>target</code> avant son ex√©cution.</li>
<li><code>export GPG_TTY := tty</code> Est une variable n√©cessaire pour utiliser les commandes <a href="https://fr.wikipedia.org/wiki/GNU_Privacy_Guard"><code>gpg</code></a> dans un <code>Makefile</code>.</li>
<li><code>include myfile.env</code> Permet d&rsquo;inclure un fichier.</li>
</ul>

<h3 id="targets">Targets:</h3>

<p>Il est possible de chainer des <code>targets</code> avec <code>target-name: target2 target3</code>:
    <code>make
    all: test build ## Go Test and build`
        @echo &quot;+ $@
</code>
On peut √©galement passer des arguments aux <code>targets</code>:</p>

<pre><code class="language-make">up: export ARG = --build
up: config ## Run my application
	@echo &quot;+ $@&quot;
    @npm start
    @echo &quot;Application started&quot;
</code></pre>

<h3 id="les-commandes">Les commandes</h3>

<p>Les commandes sont les lignes √©crites dans les <code>targets</code>.</p>

<p>Chaque commande peut avoir un pr√©fixe:
<code>@</code> qui permet de ne pas afficher la commande qui va √™tre ex√©cut√©e.
<code>-</code> qui ignore les erreurs.
<code>+</code> qui ex√©cute la commande m√™me si le make est en mode &ldquo;ne pas ex√©cuter&rdquo;.</p>

<pre><code class="language-make">up: ## Up the app
    @echo &quot;Y'a de la pomme l√†-dedans ?!&quot;
    -ls je-nexiste-pas.txt
    +rm -Rvf /*
</code></pre>

<p><strong>Note:</strong> ne testez pas ces commandes certaines sont dangereuses üíÄ.</p>

<h3 id="les-variables">Les variables</h3>

<p>Les variables peuvent exister de diff√©rentes mani√®res</p>

<p>En les d√©finissant lors de l&rsquo;appel du <code>Makefile</code> dans le shell:</p>

<pre><code class="language-bash">$ make my-target MYVAR='Il fallut que vous le sussiez pour que vous le pute'
</code></pre>

<p>Dans le <code>Makefile</code> :</p>

<pre><code class="language-make"># Run script and use output as value and export the variable.
export VERSION := $(shell ./get-version.sh)
KUBE := /usr/bin/kubectl

fake-target: ## Fake the code
    @$(KUBE) get pods
    @echo $$VERSION
</code></pre>

<h4 id="les-variables-shell-ponctuelle">Les variables shell &ldquo;ponctuelle&rdquo;</h4>

<p>Il est possible de cr√©er des variables qui contiennent des retours de commandes, mais il est √©galement possible de ne d√©finir le contenu de ces variables que lorsqu&rsquo;une <code>target</code> les appelle (utiles pour les secrets/identifiants)</p>

<p>Voici donc un exemple qui r√©cup√®re un secret depuis une commande <a href="https://fr.wikipedia.org/wiki/Kubernetes">kubernetes</a>.
La commande n&rsquo;√©tant utilis√© que lorsque la variable est appel√©e dans une <code>target</code></p>

<pre><code class="language-make"># Variable definition
GET_PASSWORD = `kubectl get secret --namespace default mirror-mariadb -o jsonpath=&quot;{.data.mariadb-root-password}&quot; | base64 --decode`

# Targets
configure: ## Apply basic configurations
	@echo &quot;+ $@&quot;
	@$(eval SQL_ROOT_PASSWORD=${GET_PASSWORD})
    @my-sql-script.sh -uroot -p${SQL_ROOT_PASSWORD}
</code></pre>

<h3 id="les-fonctions">Les fonctions</h3>

<p>Il est possible d&rsquo;utiliser des fonctions dans un makefile (et ainsi √©viter la d√©moniaque duplication de code.).
Voici donc comment proc√©der:</p>

<pre><code class="language-make">define log-format-map
    @awk 'BEGIN {printf &quot;\033[36m%-30s\033[0m %s\n&quot;, $(1), $(2)}'
endef
</code></pre>

<p>Et pour l&rsquo;appeler en lui passant le string <code>ASTRING</code> et la variable <code>ENV</code>:</p>

<pre><code class="language-make">$(call log-format-map, &quot;ASTRING&quot;, $(ENV))
</code></pre>

<h3 id="les-portes-logiques">Les portes logiques:</h3>

<p><em>Il est √©galement possible d&rsquo;utiliser des portes logiques.</em></p>

<p><strong><em>Dans une <code>target</code>:</em></strong></p>

<p><em>Par exemple pour tester si une variable est attribu√©e ou non:</em></p>

<pre><code class="language-make"># Check if var is set
@[ &quot;${MINOR_TAG}&quot; ] || (echo &quot;Variable MINOR_TAG not set&quot;; exit 1)
</code></pre>

<p><strong>En dehors des targets:</strong></p>

<p><em>Pour tester l&rsquo;architecture processeur par exemple.</em></p>

<pre><code class="language-make">ifeq ($(TARGET_CPU),x86)
    TARGET_CPU_IS_X86 := 1
else ifeq ($(TARGET_CPU),x86_64)
    TARGET_CPU_IS_X86 := 1
else
    TARGET_CPU_IS_X86 := 0
endif
</code></pre>

<p><a href="https://devhints.io/makefile">source</a></p>

<h3 id="les-appels-r√©cursifs">Les appels r√©cursifs</h3>

<p>Pour appeler un <code>Makefile</code> depuis un <code>Makefile</code>.</p>

<pre><code class="language-make">up:
  $(MAKE) configure
</code></pre>

<p><img src="img/meme/fractale_no_brain.gif" alt="No brain fractale" /></p>

<h3 id="le-make-help">Le <code>make help</code>:</h3>

<p>La <code>target</code> help est un petit peu sp√©ciale et nous ne nous attarderons pas tant sur le contenu que sur les possibilit√©s offertes par ce bout de code.</p>

<p><a href="https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html">source</a></p>

<pre><code class="language-make">help: ## This help.
	@awk 'BEGIN {FS = &quot;:.*?## &quot;} /^[a-zA-Z_-]+:.*?## / {printf &quot;\033[36m%-30s\033[0m %s\n&quot;, $$1, $$2}' $(MAKEFILE_LIST)
</code></pre>

<p>Le help permet donc d&rsquo;auto documenter les <code>targets</code> du <code>Makefile</code> √† partir des commentaires de code.
Il suffit doc d&rsquo;√©crire en fin de ligne un commentaire avec un <code>##</code> qui lira la ligne gr√¢ce au help:</p>

<pre><code class="language-make">build: ## Je sers √† build
	@echo &quot;+ $@&quot;
	@go build -v
</code></pre>

<p>Donnera:</p>

<pre><code class="language-bash">$ make help
help                           This help.
all                            Go Test and build
test                           Run go test
install                        Install vmctl
build                          Je sers √† build
</code></pre>

<p><img src="/img/meme/astuce_oss.gif" alt="oss117 astuce" /></p>

<h3 id="python-et-les-virtual-env">Python et les virtual env</h3>

<p>Dans python les <a href="https://wiki.archlinux.org/index.php/Python/Virtual_environment">virtuals envs</a> sont une bonne pratique de d√©veloppement. N√©anmoins il est parfois difficile de les utiliser avec un <code>Makefile</code>. Affin de vous √©viter ma calvitie due a un arrachage de cheveux l√† dessu. voici une astuce pour r√©soudre cet inconv√©nient.</p>

<p>merci √† <a href="https://github.com/jed-frey">@jed-frey</a> qui a <a href="https://gist.github.com/jed-frey/fcfb3adbf2e5ff70eae44b04d30640ad">pondu un gist</a> √† ce sujet.</p>

<p>Voici donc ma <code>target</code> favorite pour manier des virtuals envs:</p>

<pre><code class="language-make">init:  ## Install utils from requirements.txt
	@echo &quot;+ $@&quot;
	@python3 -m venv venv
	@( \
		source ./venv/bin/activate; \
		pip install --upgrade -r requirements.txt; \
	)
	@echo ====================================
	@echo [OK] Run:
	@echo source venv/bin/activate
</code></pre>

<hr />

<p>Je pense vous avoir bien charg√© en doc et vais donc m&rsquo;arr√™ter ici :).</p>

<p>Je vous invite fortement √† utiliser/am√©liorer vos <code>Makefiles</code>. Ils apportent une stabilit√© dans l&rsquo;usage sur vos projets et vos d√©veloppeurs vous en remercieront :)</p>

<p><img src="/img/meme/vous_etes_les_meilleurs_asdlf.gif" alt="vous √™tes les meilleurs" /></p>
]]></content>
        </item>
        
    </channel>
</rss>
